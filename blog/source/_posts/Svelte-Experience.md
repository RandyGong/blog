---
title: Svelte Experience
date: 2022-02-21 16:45:20
categories:
- Javascript
tags:
- Svelte
---

Recently, I learned about a new frontend framework -- Svelte, which has opened up a different strategic route from the three frameworks. Here I mainly quote Vue author Evan you's views on svelte.

https://www.zhihu.com/question/53150351

The author is Rich Harris, the author of Reactive, Rollup and Buble. He can be called the brother wheel in the frontend world. Now he has brought a new wheel!

The API design of this framework is inherited from Reactive (naturally, it is very similar to Vue), but this is not the point. The core idea of Svelte is to "reduce the amount of code when the framework runs through static compilation". For example, no matter how you compile the current framework, whether it is React Angular or Vue, it must be "referenced" when using it The framework itself is called the runtime. But using Svelte is different. After a Svelte component is compiled, all the required runtime code is included. In addition to introducing the component itself, you don't need to introduce an additional so-called framework runtime!

Of course, this does not mean that svelte does not have a runtime, but the cost can be small for two reasons:

1) Svelte's compilation style is to compile templates into imperative native DOM operations. For example, this template:


```JavaScript
<a>{{ msg }}</a>
```

It will be compiled into the following code:

```JavaScript
function renderMainFragment ( root, component, target ) {
	var a = document.createElement( 'a' );
	
	var text = document.createTextNode( root.msg );
	a.appendChild( text );
	
	target.appendChild( a )

	return {
		update: function ( changed, root ) {
			text.data = root.msg;
		},

		teardown: function ( detach ) {
			if ( detach ) a.parentNode.removeChild( a );
		}
	};
}
```

It can be seen that compared with the framework based on virtual DOM, such output does not need the diff / patch operation of virtual DOM, which can naturally save a lot of code. At the same time, The performance is almost the same as that of vanilla JS (just for this simple example), and the memory consumption is even better. This idea is not its initiative. Monkberry.js, a template engine with performance explosion table, has been implemented in this way, and the template compilation of NG2 is actually very similar to this one (but a rendering abstraction layer is added in the middle).

2) For specific functions, Svelte still has corresponding runtime code, such as component logic, if / else switching logic, loop logic, etc But when it is compiled, if a function is not used, the corresponding code will not be compiled into the result at all. It's like that the helpers of functions not used in Babel will not be introduced, and it's like that only the corresponding functions are selectively introduced in lodash or Rxjs.
Based on these two characteristics, the final amount of code for svelte applications can be very small. For example, its TodoMVC min+gzip has only 3KB.

However, svelte is not without its potential problems:

1) Although the amount of code in a simple demo is indeed very small, the amount of code generated by the same component template is larger than that generated by the vdom rendering function, There will be a lot of duplicate code in multiple components (although gzip can be alleviated, parse and evaluate are inevitable). The more components in the project, the smaller the difference in the amount of code. At the same time, it is not really "no runtime" as advertised ", but just import according to your code on demand. The more functions you use, the more runtime code Svelte needs to contain. In fact, it is difficult to say how many size advantages it can have in the actual production project.

2) The performance of Svelte in large applications remains to be seen, especially in the case of a large number of dynamic content and nested components. Its update strategy determines that it also needs a mechanism similar to react's shouldcomponentupdate to prevent over update. On the other hand, its performance advantages are not qualitatively different from the current mainstream frameworks. The performance of most mainstream frameworks can be 1.2 ~ 1.5 times slower than that of vanilla JS, and the Inferno based on virtual DOM is closer to native, which proves the theoretical possibility of virtual dom, Therefore, it can be predicted that the performance bottleneck of the web in the future is more the DOM itself than the framework.

3) The performance of Svelte in large applications remains to be seen, especially in the case of a large number of dynamic content and nested components. Its update strategy determines that it also needs a mechanism similar to react's shouldcomponentupdate to prevent over update. On the other hand, its performance advantages are not qualitatively different from the current mainstream frameworks. The performance of most mainstream frameworks can be 1.2 ~ 1.5 times slower than that of vanilla JS, and the Inferno based on virtual DOM is closer to native, which proves the theoretical possibility of virtual dom, Therefore, it can be predicted that the performance bottleneck of the web in the future is more the DOM itself than the framework.

Finally, I personally think the advantage of Svelte is that it is used to compile web components that can be distributed independently. The biggest problem with the combination of traditional frameworks and web components lies in the Runtime: when the framework runtime is directly packaged in the separately distributed WC, it means that each component has to copy a framework; If you don't pack it, you can't use it out of the box. However, Svelte is the least limited by this problem (there is still the problem of duplicate code, but it depends on how many functions you use), which can be said to be the most suitable framework for this use case.
